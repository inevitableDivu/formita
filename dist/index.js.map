{"version":3,"file":"index.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.mjs","../src/hooks/useFormita.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { useCallback, useEffect, useMemo, useState } from 'react'\r\n\r\nexport type IError = {\r\n\tmessage: string\r\n} | null\r\n\r\nexport type IUserInputParams = Record<\r\n\tstring,\r\n\t| {\r\n\t\t\ttype: 'email' | 'text' | 'password'\r\n\t\t\tvalue?: unknown\r\n\t  }\r\n\t| {\r\n\t\t\ttype: 'number'\r\n\t\t\tvalue?: number\r\n\t\t\tlimit: number\r\n\t  }\r\n>\r\n\r\nexport type IFormDataTypes = 'email' | 'text' | 'password' | 'number'\r\n\r\nexport type INumberForm = {\r\n\tvalue: string\r\n\terror: IError\r\n\tlimit: number\r\n\ttype: 'number'\r\n}\r\n\r\nexport type IOtherType<T> = {\r\n\ttype: 'email' | 'text' | 'password'\r\n\tvalue: unknown extends T ? string : T\r\n\terror: IError\r\n\tlimit: number\r\n}\r\n\r\nexport type IUserInputForm<T extends IUserInputParams> = {\r\n\t[P in keyof T]: INumberForm | IOtherType<T[P]['value']>\r\n}\r\n\r\nexport function validate(value: string, type: 'email' | 'password'): IError\r\n\r\n/**\r\n * This function validates an input value as either an email or password and returns an error message\r\n * if the input is invalid.\r\n * @param {string} value - The input value that needs to be validated.\r\n * @param {'email' | 'password'} type - The type parameter is a string literal type that can only have\r\n * two possible values: 'email' or 'password'. It is used to determine the type of validation to\r\n * perform on the value parameter.\r\n * @returns an object of type `IError` which contains a `message` property. The value of the `message`\r\n * property depends on the validation rules for the input `value` and `type`. If the input is valid,\r\n * the function returns `null`.\r\n */\r\nexport function validate(value: string, type: 'email' | 'password'): IError {\r\n\tif (value.length === 0)\r\n\t\treturn {\r\n\t\t\tmessage: 'Input field cannot be empty'\r\n\t\t}\r\n\r\n\tif (type === 'email') {\r\n\t\tconst check = /^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,5}$/g\r\n\t\tif (check.test(value)) return null\r\n\t\telse\r\n\t\t\treturn {\r\n\t\t\t\tmessage: 'Invalid e-mail entered'\r\n\t\t\t}\r\n\t}\r\n\r\n\tif (type === 'password') {\r\n\t\tif (value.length < 6)\r\n\t\t\treturn {\r\n\t\t\t\tmessage: 'Password must contain atleat 6 characters'\r\n\t\t\t}\r\n\t\telse null\r\n\t}\r\n\r\n\treturn null\r\n}\r\n\r\nexport function useFormita<T extends IUserInputParams>(\r\n\tparams: T\r\n): {\r\n\t/**\r\n\t * The function handleChange is a TypeScript function that validates user input for a form and updates\r\n\t * the form state accordingly.\r\n\t * @param {P} target - A key of the generic type T, which represents the field in the form that is\r\n\t * being changed.\r\n\t * @returns A function that takes in a parameter `text` and performs validation based on the type of\r\n\t * the `formTarget` input field. It then updates the `form` state with the new `text` value and any\r\n\t * validation error. Finally, it returns the validation error.\r\n\t */\r\n\thandleChange: <P extends keyof T>(\r\n\t\ttarget: P\r\n\t) => (\r\n\t\ttext: string | (unknown extends T[P]['value'] ? string : T[P]['value'])\r\n\t) => IError\r\n\tform: IUserInputForm<T>\r\n\t/**\r\n\t * This is a TypeScript function that handles form submission with error handling and loading state\r\n\t * management.\r\n\t * @param cb - A callback function that takes in the user input form data as an argument and performs\r\n\t * some action with it.\r\n\t * @param [errorCallback] - The errorCallback parameter is an optional function that takes an error\r\n\t * object as its argument and handles any errors that occur during the form submission process.\r\n\t * @param [complete] - The `complete` parameter is an optional callback function that will be called\r\n\t * after the `cb` function has been executed and the `try` block has been completed, regardless of\r\n\t * whether there was an error or not. It can be used to perform any cleanup or additional actions\r\n\t * after the form submission is complete\r\n\t * @returns A function that handles form submission and calls the provided callback function with the\r\n\t * form data if there are no errors. It also handles errors and calls the provided error callback\r\n\t * function if there is an error. Additionally, it sets the loading state to true during form\r\n\t * submission and sets it back to false after completion.\r\n\t */\r\n\thandleOnSubmit: (\r\n\t\tcb: (data: IUserInputForm<T>) => void,\r\n\t\terrorCallback?: ((error: IError) => void) | undefined,\r\n\t\tcomplete?: (() => void) | undefined\r\n\t) => () => Promise<void>\r\n\tloading: boolean\r\n\tdisabled: boolean\r\n}\r\n\r\n/**\r\n * This is a TypeScript function that creates a form with input fields and handles form submission with\r\n * validation and error handling.\r\n * @param {T} params - The `params` parameter is an object that contains the initial values and\r\n * configurations for the form inputs. It is a generic type `T` that extends `IUserInputParams`, which\r\n * is an interface that defines the properties of each input field (e.g. `value`, `type`, `limit`\r\n * @returns The `useFormita` hook returns an object with the following properties: `handleChange`,\r\n * `form`, `handleOnSubmit`, `loading`, and `disabled`.\r\n */\r\nexport function useFormita<T extends IUserInputParams>(params: T) {\r\n\tconst [loading, setLoading] = useState(false)\r\n\tconst [disabled, setDisabled] = useState(false)\r\n\tconst formData = useMemo(() => {\r\n\t\tconst obj: T = { ...params }\r\n\t\tlet newObj: object = {}\r\n\t\tObject.keys(obj).map((key) => {\r\n\t\t\tlet index = key as keyof T\r\n\t\t\tlet objChild = obj[index]\r\n\t\t\tnewObj = {\r\n\t\t\t\t...(newObj ?? ({} as IUserInputForm<T>)),\r\n\t\t\t\t[index]: {\r\n\t\t\t\t\t...obj[index],\r\n\t\t\t\t\tvalue: objChild.value ?? '',\r\n\t\t\t\t\ttype: objChild.type\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\r\n\t\treturn newObj as IUserInputForm<T>\r\n\t}, [])\r\n\tconst [form, setForm] = useState<IUserInputForm<T>>(formData)\r\n\r\n\t/**\r\n\t * The function handleChange is a TypeScript function that validates user input for a form and updates\r\n\t * the form state accordingly.\r\n\t * @param {P} target - A key of the generic type T, which represents the field in the form that is\r\n\t * being changed.\r\n\t * @returns A function that takes in a parameter `text` and performs validation based on the type of\r\n\t * the `formTarget` input field. It then updates the `form` state with the new `text` value and any\r\n\t * validation error. Finally, it returns the validation error.\r\n\t */\r\n\tconst handleChange = useCallback(\r\n\t\t<P extends keyof T>(target: P) => {\r\n\t\t\tconst formTarget = form[target] as IUserInputForm<T>[P]\r\n\t\t\tconst limit = formTarget.type === 'number' ? formTarget.limit : 1\r\n\r\n\t\t\treturn (text: typeof formTarget.value) => {\r\n\t\t\t\tlet error: IError = null\r\n\t\t\t\tif (\r\n\t\t\t\t\tformTarget.type === 'email' ||\r\n\t\t\t\t\tformTarget.type === 'password'\r\n\t\t\t\t) {\r\n\t\t\t\t\terror = validate(String(text), formTarget.type)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (formTarget.type === 'text') {\r\n\t\t\t\t\terror =\r\n\t\t\t\t\t\tString(text).length < 1\r\n\t\t\t\t\t\t\t? { message: 'Input field cannot be empty!' }\r\n\t\t\t\t\t\t\t: null\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (formTarget.type === 'number') {\r\n\t\t\t\t\tif (text === '') {\r\n\t\t\t\t\t\terror = {\r\n\t\t\t\t\t\t\tmessage: 'Input field cannot be empty!'\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (isNaN(Number(text))) {\r\n\t\t\t\t\t\terror = {\r\n\t\t\t\t\t\t\tmessage: 'Invalid data provided!'\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else if (String(text).length > limit) {\r\n\t\t\t\t\t\terror = {\r\n\t\t\t\t\t\t\tmessage: 'Invalid length of characters!'\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tsetForm((data) => ({\r\n\t\t\t\t\t...data,\r\n\t\t\t\t\t[target]: { ...data[target], value: text, error }\r\n\t\t\t\t}))\r\n\r\n\t\t\t\treturn error\r\n\t\t\t}\r\n\t\t},\r\n\t\t[form]\r\n\t)\r\n\r\n\t/**\r\n\t * This is a TypeScript function that handles form submission with error handling and loading state\r\n\t * management.\r\n\t * @param cb - A callback function that takes in the user input form data as an argument and performs\r\n\t * some action with it.\r\n\t * @param [errorCallback] - The errorCallback parameter is an optional function that takes an error\r\n\t * object as its argument and handles any errors that occur during the form submission process.\r\n\t * @param [complete] - The `complete` parameter is an optional callback function that will be called\r\n\t * after the `cb` function has been executed and the `try` block has been completed, regardless of\r\n\t * whether there was an error or not. It can be used to perform any cleanup or additional actions\r\n\t * after the form submission is complete\r\n\t * @returns A function that handles form submission and calls the provided callback function with the\r\n\t * form data if there are no errors. It also handles errors and calls the provided error callback\r\n\t * function if there is an error. Additionally, it sets the loading state to true during form\r\n\t * submission and sets it back to false after completion.\r\n\t */\r\n\tconst handleOnSubmit = useCallback(\r\n\t\t(\r\n\t\t\tcb: (data: IUserInputForm<T>) => void,\r\n\t\t\terrorCallback?: (error: IError) => void,\r\n\t\t\tcomplete?: () => void\r\n\t\t) => {\r\n\t\t\treturn async () => {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tsetLoading(true)\r\n\t\t\t\t\tconst error = Object.keys(form).find((item) =>\r\n\t\t\t\t\t\tBoolean(form[item as keyof T].error)\r\n\t\t\t\t\t) as keyof T\r\n\r\n\t\t\t\t\tconst errorIndex = Object.keys(form).find(\r\n\t\t\t\t\t\t(item) => String(form[item as keyof T].value).length < 1\r\n\t\t\t\t\t)\r\n\r\n\t\t\t\t\tif (error) {\r\n\t\t\t\t\t\tconsole.log(error)\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (errorIndex) {\r\n\t\t\t\t\t\tsetForm((old) => ({\r\n\t\t\t\t\t\t\t...old,\r\n\t\t\t\t\t\t\t[errorIndex]: {\r\n\t\t\t\t\t\t\t\t...old[errorIndex],\r\n\t\t\t\t\t\t\t\terror: {\r\n\t\t\t\t\t\t\t\t\tmessage: 'Input field cannot be empty!'\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}))\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tawait cb(form)\r\n\t\t\t\t} catch (error) {\r\n\t\t\t\t\tconst message =\r\n\t\t\t\t\t\ttypeof error?.response?.data === 'string'\r\n\t\t\t\t\t\t\t? error.response.data\r\n\t\t\t\t\t\t\t: typeof error?.response?.data === 'object'\r\n\t\t\t\t\t\t\t? error.response.data.message\r\n\t\t\t\t\t\t\t: error.message\r\n\t\t\t\t\terrorCallback?.({\r\n\t\t\t\t\t\tmessage\r\n\t\t\t\t\t})\r\n\t\t\t\t} finally {\r\n\t\t\t\t\tcomplete?.()\r\n\t\t\t\t\tsetLoading(false)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\t\t[form]\r\n\t)\r\n\r\n\tuseEffect(() => {\r\n\t\tconst check = Object.keys(form).find((item) => {\r\n\t\t\treturn Boolean(form[item as keyof T].error)\r\n\t\t})\r\n\r\n\t\tif (check) {\r\n\t\t\tsetDisabled(true)\r\n\t\t} else {\r\n\t\t\tsetDisabled(false)\r\n\t\t}\r\n\t}, [form])\r\n\r\n\treturn { handleChange, form, handleOnSubmit, loading, disabled }\r\n}\r\n"],"names":["validate","value","type","length","message","check","test","useFormita","params","_useState","useState","loading","setLoading","_useState2","disabled","setDisabled","formData","useMemo","obj","_extends","newObj","Object","keys","map","key","index","objChild","_newObj","_extends2","_objChild$value","_useState3","form","setForm","handleChange","useCallback","target","formTarget","limit","text","error","String","isNaN","Number","data","_extends3","handleOnSubmit","cb","errorCallback","complete","find","item","Boolean","errorIndex","console","log","old","_extends4","Promise","resolve","then","_error$response","_error$response2","response","_wasThrown","_result","e","reject","useEffect"],"mappings":";;;;;;;;;;;;;;;;;AAAA;AAmKA;AACO,MAAM,eAAe,iBAAiB,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,QAAQ,KAAK,MAAM,CAAC,QAAQ,GAAG,MAAM,CAAC,iBAAiB,CAAC,CAAC,IAAI,YAAY,CAAC;AA4D/J;AACO,MAAM,oBAAoB,iBAAiB,OAAO,MAAM,KAAK,WAAW,IAAI,MAAM,CAAC,aAAa,KAAK,MAAM,CAAC,aAAa,GAAG,MAAM,CAAC,sBAAsB,CAAC,CAAC,IAAI,iBAAiB,CAAC;AA+UxL;AACA;AACO,SAAS,MAAM,CAAC,IAAI,EAAE,OAAO,EAAE;AACtC,CAAC,IAAI;AACL,EAAE,IAAI,MAAM,GAAG,IAAI,EAAE,CAAC;AACtB,EAAE,CAAC,MAAM,CAAC,EAAE;AACZ,EAAE,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC;AACpB,EAAE;AACF,CAAC,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,EAAE;AAC5B,EAAE,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC;AACtC,EAAE;AACF,CAAC,OAAO,MAAM,CAAC;AACf,CAAC;AACD;AACA;AACO,SAAS,gBAAgB,CAAC,IAAI,EAAE,SAAS,EAAE;AAClD,CAAC,IAAI;AACL,EAAE,IAAI,MAAM,GAAG,IAAI,EAAE,CAAC;AACtB,EAAE,CAAC,OAAO,CAAC,EAAE;AACb,EAAE,OAAO,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;AAC5B,EAAE;AACF,CAAC,IAAI,MAAM,IAAI,MAAM,CAAC,IAAI,EAAE;AAC5B,EAAE,OAAO,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,SAAS,CAAC,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;AAC9E,EAAE;AACF,CAAC,OAAO,SAAS,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;AACjC;;SCrhBgBA,QAAQA,CAACC,KAAa,EAAEC,IAA0B;EACjE,IAAID,KAAK,CAACE,MAAM,KAAK,CAAC,EACrB,OAAO;IACNC,OAAO,EAAE;GACT;EAEF,IAAIF,IAAI,KAAK,OAAO,EAAE;IACrB,IAAMG,KAAK,GAAG,mCAAmC;IACjD,IAAIA,KAAK,CAACC,IAAI,CAACL,KAAK,CAAC,EAAE,OAAO,IAAI,CAAA,KAEjC,OAAO;MACNG,OAAO,EAAE;KACT;;EAGH,IAAIF,IAAI,KAAK,UAAU,EAAE;IACxB,IAAID,KAAK,CAACE,MAAM,GAAG,CAAC,EACnB,OAAO;MACNC,OAAO,EAAE;KACT,CAAA;;EAIH,OAAO,IAAI;AACZ;AAsDA,SAAgBG,UAAUA,CAA6BC,MAAS;EAC/D,IAAAC,SAAA,GAA8BC,cAAQ,CAAC,KAAK,CAAC;IAAtCC,OAAO,GAAAF,SAAA;IAAEG,UAAU,GAAAH,SAAA;EAC1B,IAAAI,UAAA,GAAgCH,cAAQ,CAAC,KAAK,CAAC;IAAxCI,QAAQ,GAAAD,UAAA;IAAEE,WAAW,GAAAF,UAAA;EAC5B,IAAMG,QAAQ,GAAGC,aAAO,CAAC;IACxB,IAAMC,GAAG,GAAAC,QAAA,KAAWX,MAAM,CAAE;IAC5B,IAAIY,MAAM,GAAW,EAAE;IACvBC,MAAM,CAACC,IAAI,CAACJ,GAAG,CAAC,CAACK,GAAG,CAAC,UAACC,GAAG;;MACxB,IAAIC,KAAK,GAAGD,GAAc;MAC1B,IAAIE,QAAQ,GAAGR,GAAG,CAACO,KAAK,CAAC;MACzBL,MAAM,GAAAD,QAAA,MAAAQ,OAAA,GACDP,MAAM,YAAAO,OAAA,GAAK,EAAwB,GAAAC,SAAA,OAAAA,SAAA,CACtCH,KAAK,IAAAN,QAAA,KACFD,GAAG,CAACO,KAAK,CAAC;QACbxB,KAAK,GAAA4B,eAAA,GAAEH,QAAQ,CAACzB,KAAK,YAAA4B,eAAA,GAAI,EAAE;QAC3B3B,IAAI,EAAEwB,QAAQ,CAACxB;UAAI0B,SAAA,EAEpB;KACD,CAAC;IAEF,OAAOR,MAA2B;GAClC,EAAE,EAAE,CAAC;EACN,IAAAU,UAAA,GAAwBpB,cAAQ,CAAoBM,QAAQ,CAAC;IAAtDe,IAAI,GAAAD,UAAA;IAAEE,OAAO,GAAAF,UAAA;EAWpB,IAAMG,YAAY,GAAGC,iBAAW,CAC/B,UAAoBC,MAAS;IAC5B,IAAMC,UAAU,GAAGL,IAAI,CAACI,MAAM,CAAyB;IACvD,IAAME,KAAK,GAAGD,UAAU,CAAClC,IAAI,KAAK,QAAQ,GAAGkC,UAAU,CAACC,KAAK,GAAG,CAAC;IAEjE,OAAO,UAACC,IAA6B;MACpC,IAAIC,KAAK,GAAW,IAAI;MACxB,IACCH,UAAU,CAAClC,IAAI,KAAK,OAAO,IAC3BkC,UAAU,CAAClC,IAAI,KAAK,UAAU,EAC7B;QACDqC,KAAK,GAAGvC,QAAQ,CAACwC,MAAM,CAACF,IAAI,CAAC,EAAEF,UAAU,CAAClC,IAAI,CAAC;;MAGhD,IAAIkC,UAAU,CAAClC,IAAI,KAAK,MAAM,EAAE;QAC/BqC,KAAK,GACJC,MAAM,CAACF,IAAI,CAAC,CAACnC,MAAM,GAAG,CAAC,GACpB;UAAEC,OAAO,EAAE;SAAgC,GAC3C,IAAI;;MAGT,IAAIgC,UAAU,CAAClC,IAAI,KAAK,QAAQ,EAAE;QACjC,IAAIoC,IAAI,KAAK,EAAE,EAAE;UAChBC,KAAK,GAAG;YACPnC,OAAO,EAAE;WACT;SACD,MAAM,IAAIqC,KAAK,CAACC,MAAM,CAACJ,IAAI,CAAC,CAAC,EAAE;UAC/BC,KAAK,GAAG;YACPnC,OAAO,EAAE;WACT;SACD,MAAM,IAAIoC,MAAM,CAACF,IAAI,CAAC,CAACnC,MAAM,GAAGkC,KAAK,EAAE;UACvCE,KAAK,GAAG;YACPnC,OAAO,EAAE;WACT;;;MAIH4B,OAAO,CAAC,UAACW,IAAI;QAAA,IAAAC,SAAA;QAAA,OAAAzB,QAAA,KACTwB,IAAI,GAAAC,SAAA,OAAAA,SAAA,CACNT,MAAM,IAAAhB,QAAA,KAAQwB,IAAI,CAACR,MAAM,CAAC;UAAElC,KAAK,EAAEqC,IAAI;UAAEC,KAAK,EAALA;YAAKK,SAAA;OAC9C,CAAC;MAEH,OAAOL,KAAK;KACZ;GACD,EACD,CAACR,IAAI,CAAC,CACN;EAkBD,IAAMc,cAAc,GAAGX,iBAAW,CACjC,UACCY,EAAqC,EACrCC,aAAuC,EACvCC,QAAqB;IAErB;MAAA;;oCACK;YACHpC,UAAU,CAAC,IAAI,CAAC;YAChB,IAAM2B,KAAK,GAAGlB,MAAM,CAACC,IAAI,CAACS,IAAI,CAAC,CAACkB,IAAI,CAAC,UAACC,IAAI;cAAA,OACzCC,OAAO,CAACpB,IAAI,CAACmB,IAAe,CAAC,CAACX,KAAK,CAAC;cACzB;YAEZ,IAAMa,UAAU,GAAG/B,MAAM,CAACC,IAAI,CAACS,IAAI,CAAC,CAACkB,IAAI,CACxC,UAACC,IAAI;cAAA,OAAKV,MAAM,CAACT,IAAI,CAACmB,IAAe,CAAC,CAACjD,KAAK,CAAC,CAACE,MAAM,GAAG,CAAC;cACxD;YAED,IAAIoC,KAAK,EAAE;cACVc,OAAO,CAACC,GAAG,CAACf,KAAK,CAAC;cAClB;;YAGD,IAAIa,UAAU,EAAE;cACfpB,OAAO,CAAC,UAACuB,GAAG;gBAAA,IAAAC,SAAA;gBAAA,OAAArC,QAAA,KACRoC,GAAG,GAAAC,SAAA,OAAAA,SAAA,CACLJ,UAAU,IAAAjC,QAAA,KACPoC,GAAG,CAACH,UAAU,CAAC;kBAClBb,KAAK,EAAE;oBACNnC,OAAO,EAAE;;oBACToD,SAAA;eAED,CAAC;cACH;;YACA,OAAAC,OAAA,CAAAC,OAAA,CAEKZ,EAAE,CAACf,IAAI,CAAC,EAAA4B,IAAA;WACd,YAAQpB,KAAK,EAAE;YAAA,IAAAqB,eAAA,EAAAC,gBAAA;YACf,IAAMzD,OAAO,GACZ,QAAOmC,KAAK,aAALA,KAAK,wBAAAqB,eAAA,GAALrB,KAAK,CAAEuB,QAAQ,cAAAF,eAAA,uBAAfA,eAAA,CAAiBjB,IAAI,MAAK,QAAQ,GACtCJ,KAAK,CAACuB,QAAQ,CAACnB,IAAI,GACnB,QAAOJ,KAAK,aAALA,KAAK,wBAAAsB,gBAAA,GAALtB,KAAK,CAAEuB,QAAQ,cAAAD,gBAAA,uBAAfA,gBAAA,CAAiBlB,IAAI,MAAK,QAAQ,GACzCJ,KAAK,CAACuB,QAAQ,CAACnB,IAAI,CAACvC,OAAO,GAC3BmC,KAAK,CAACnC,OAAO;YACjB2C,aAAa,aAAbA,aAAa,uBAAbA,aAAa,CAAG;cACf3C,OAAO,EAAPA;aACA,CAAC;WACF;qBAAA2D,UAAA,EAAAC,OAAA;UACAhB,QAAQ,aAARA,QAAQ,uBAARA,QAAQ,EAAI;UACZpC,UAAU,CAAC,KAAK,CAAC;UAAA,IAAAmD,UAAA,QAAAC,OAAA;UAAA,OAAAA,OAAA;;OAElB,QAAAC,CAAA;QAAA,OAAAR,OAAA,CAAAS,MAAA,CAAAD,CAAA;;;GACD,EACD,CAAClC,IAAI,CAAC,CACN;EAEDoC,eAAS,CAAC;IACT,IAAM9D,KAAK,GAAGgB,MAAM,CAACC,IAAI,CAACS,IAAI,CAAC,CAACkB,IAAI,CAAC,UAACC,IAAI;MACzC,OAAOC,OAAO,CAACpB,IAAI,CAACmB,IAAe,CAAC,CAACX,KAAK,CAAC;KAC3C,CAAC;IAEF,IAAIlC,KAAK,EAAE;MACVU,WAAW,CAAC,IAAI,CAAC;KACjB,MAAM;MACNA,WAAW,CAAC,KAAK,CAAC;;GAEnB,EAAE,CAACgB,IAAI,CAAC,CAAC;EAEV,OAAO;IAAEE,YAAY,EAAZA,YAAY;IAAEF,IAAI,EAAJA,IAAI;IAAEc,cAAc,EAAdA,cAAc;IAAElC,OAAO,EAAPA,OAAO;IAAEG,QAAQ,EAARA;GAAU;AACjE;;;;;"}